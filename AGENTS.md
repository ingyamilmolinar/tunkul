# Project Guidelines
- Use Go 1.23.x as specified in `go.mod`.
- **Run the unit tests before opening a PR.** Use the stubbed Ebiten API via
  `go test -tags test -modfile=go.test.mod -timeout 1s ./...` for maximum portability.
  If your system has a working X11 environment you may instead execute
  `xvfb-run go test -timeout 1s ./...` to test against the real Ebiten library.
- **Always build and run tests before pushing or creating a PR** using
  `go test -tags test -modfile=go.test.mod -timeout 1s ./...` and `make wasm`.
  After every set of changes, also run `make test-real` to ensure that the
  tests pass with the real Ebiten library, not just the mocked one.
- **Verify the desktop game runs.** Execute `make run` (use
  `xvfb-run make run RUN_ARGS=-demo` in headless environments) and confirm the
  sample demo circuit starts without errors.
- The `src/js/main.wasm` file is generated by `make`; avoid committing changes to it.
- UI code resides under `src/go/internal/ui`. The test suite can run either
  against a stubbed Ebiten (`go.test.mod`) or the real library.
- For native builds using the real Ebiten library, run `scripts/setup-ebiten-env.sh`
  to install the necessary system packages (Homebrew or apt).
- Building with the real Ebiten module requires network access on the first run
  so Go can download dependencies. If networking is disabled, use the stubbed
  modules or ensure all packages are vendored.

### Git sync
After cloning the repository, make sure your local branch tracks the latest
remote branch used for development:

```sh
git remote add origin https://github.com/ingyamilmolinar/tunkul.git  # if not set
git fetch origin
git pull --no-rebase origin <development-branch>
```
Resolve any merge conflicts before proceeding.

### Headless X11
Install `xvfb` and run the game via `xvfb-run` on systems without a display:

```sh
sudo apt-get install -y xvfb
xvfb-run go run ./cmd/tunkul.go
```
The virtual framebuffer lets Ebiten create a window while logs are printed to the console.

## Project Overview
Tunkul is a grid-based beat sequencer written in Go with Ebiten. The program
renders a node graph where each node represents a drum hit. A bottom drum-machine
panel shows the active steps. The scheduler in `core/beat` triggers beats at a
configurable BPM using the pure data structures from `core/model`. The UI layer
translates mouse and keyboard input into model operations and draws the results
with Ebiten.

Key technologies:
- Go 1.23
- Ebiten for cross-platform rendering (stubbed for headless tests)
- WASM build via `make wasm`

### Git hooks
Run the following command once after cloning to ensure tests and the wasm build
run before every commit:

```sh
git config core.hooksPath .githooks
```

The provided pre-commit hook formats code, runs `go test -tags test -modfile=go.test.mod -timeout 1s ./...`,
and runs `make wasm`.

Code structure:
- `core/model` – pure graph and drum row logic (unit tested)
- `core/beat` – beat scheduler (integration tested)
- `internal/ui` – controller and renderer using Ebiten. Input helpers can be
  swapped during tests with `SetInputForTest` so UI logic can run headlessly.
  UI functional tests live in this package and verify button behaviour and
  layout sizing.

## Learnings from Bug Fixing
*   **UI Debugging with Logs:** For UI-related bugs, extensive logging of UI and logic states is crucial. `log.Printf` statements at key points (e.g., `Update` loops, state changes, event handlers) provide invaluable insight into runtime behavior that unit tests alone cannot capture.
*   **Functional Testing for UI:** Unit tests are good for isolated logic, but functional tests that simulate user interactions (like button clicks) and assert on visual outcomes (e.g., pulse animation, drum row content) are essential for UI correctness.
*   **Clear Separation of Concerns:** Ensuring a clear separation between the model (pure data and logic), the scheduler (beat timing), and the UI (rendering and input) simplifies debugging and testing. Changes in one layer should propagate predictably to others.
*   **Graph Traversal for Derived Data:** When UI elements (like the drum beat row) are derived from a complex data structure (like a node graph), implement explicit traversal logic (e.g., BFS/DFS) to generate the derived data. Avoid direct manipulation of derived data in multiple places.
*   **Test Setup and Teardown:** Pay close attention to test setup (`New()`, `Layout()`, `StartNodeID` initialization) and teardown (`defer restore()`) to ensure tests are isolated and repeatable.
*   **Iterative Refinement:** Debugging complex interactions often requires an iterative approach: add logs, observe, refine code, re-test. Don't afraid to revert changes if they lead to more issues.

## Learnings from Signal Propagation Bug
This debugging session highlighted several critical points:

*   **Precise `replace` command usage:** The `replace` tool requires an *exact* match for `old_string`, including all whitespace and newlines. Even a single character mismatch will result in failure. When encountering "0 occurrences found," it's crucial to re-read the target file to get the exact content.
*   **Avoiding infinite loops:** When a fix involves multiple interdependent changes (code and tests), it's easy to get into a loop where fixing one part breaks another, or the changes aren't applied correctly. A systematic approach is vital:
    1.  **Isolate the problem:** Use logging and targeted tests to narrow down the root cause.
    2.  **Plan changes comprehensively:** Before making any changes, outline all necessary modifications to code and tests.
    3.  **Apply changes incrementally:** Make small, verifiable changes and run tests after each step.
    4.  **Prioritize core logic:** Ensure the fundamental behavior is correct before addressing secondary issues.
    5.  **Re-evaluate assumptions:** If a fix isn't working, question underlying assumptions about the code's behavior.
*   **Clear Separation of Concerns (Revisited):** The initial bug stemmed from the scheduler having too much knowledge about the graph structure. By simplifying the scheduler to only provide a basic `OnTick` event and moving the graph traversal and pulse propagation logic to the UI layer (`game.go`), the system became much more modular and easier to debug. This reinforces the principle that each component should have a single, well-defined responsibility.
*   **Event-driven architecture:** Implementing pulse propagation as an event-driven system (where a pulse completing its animation triggers the next node) is more robust and intuitive than a centralized scheduler trying to manage all node activations. This allows for more complex and dynamic signal flows.
*   **Test synchronization:** When refactoring core logic, tests need to be updated to reflect the new behavior. It's important to understand *why* a test is failing (e.g., due to a bug or an outdated expectation) and adjust it accordingly. Adding logging to tests can help verify that the test setup and execution are behaving as expected.
*   **Directed Graph Edge Consistency:** When working with directed graphs, ensure that edge creation consistently reflects the intended direction. Incorrectly swapping 'from' and 'to' nodes during intermediate node generation can lead to subtle bugs in graph traversal and cycle detection, as the underlying graph structure might not match the logical flow. Always verify that the graph's internal representation of edges aligns with the conceptual direction of connections. This was the root cause of the `IsLoop` function failing to detect cycles in `TestDrumViewLooping`.

## Lessons from Highlight Rendering Refactor
*   **Injectable rendering helpers:** Defining drawing primitives as variables allows tests to capture render calls without relying on pixel buffers, closing the gap between logic state and visual output.
*   **Centralized highlight bookkeeping:** Small helper methods to add and expire beat highlights make the pulse traversal logic easier to reason about and avoid dangling highlights.
*   **Conditional beat-row recomputation:** Rebuilding drum rows only when their length changes keeps the UI in sync with the graph while avoiding unnecessary work each frame.

## Lessons from Invisible Node Handling
*   **Upgrade placeholders on demand:** When a user tries to place a node where an invisible placeholder exists, automatically promote it to a regular node so intersections always accept new placements.

## Lessons from Audio Integration
*   **Procedural sound plugins:** Generate percussion without binary assets by exposing a `register/play` API in JS and invoking it via a `playSound` function variable in Go so tests can intercept calls.
*   **Uncapped TPS for smoother timing:** Running Ebiten with `SetMaxTPS(0)` removes the default tick limit, keeping visual pulses and audio in sync with the scheduler's BPM.
*   **Resume Web Audio contexts:** Browsers start `AudioContext` in a suspended state; calling `resume()` on first playback ensures sounds are heard after a user gesture. Native builds use Oto to synthesize a noise-based snare.
*   **Load audio modules before WASM:** Import ES modules like `audio.js` inside a module script that also boots the WASM game so the JS bridge functions (e.g., `play`) are defined before Go tries to call them.

## Lessons from Audio Loop Consistency
*   **Highlight-driven sound:** Invoke audio playback from the beat-highlighting routine so signal traversal, drum view highlighting, and audible cues remain in lockstep—even through graph loops.
