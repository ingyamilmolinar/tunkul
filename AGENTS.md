# Project Guidelines
- **Before running any commands, execute `sudo make dependencies`** to install all required system and Node packages. This may take several minutes but prevents environment-related failures.
- **Before opening any PR, run `make wasm` and `make test-real`** (even if they are no-ops on systems without native dependencies) unless explicitly instructed to skip them.
- Use Go 1.23.x as specified in `go.mod`.
- **Run the unit tests before opening a PR.** Use the stubbed Ebiten API via
  `go test -tags test -modfile=go.test.mod -timeout 1s ./...` for maximum portability.
  If your system has a working X11 environment you may instead execute
  `xvfb-run go test -timeout 1s ./...` to test against the real Ebiten library.
- **Always build and run tests before pushing or creating a PR** using
  `go test -tags test -modfile=go.test.mod -timeout 1s ./...` and `make wasm`.
  After every set of changes, also run `make test-real` to ensure that the
  tests pass with the real Ebiten library, not just the mocked one.
- **Verify the desktop game runs.** Execute `make run` (use
  `xvfb-run make run RUN_ARGS=-demo` in headless environments) and confirm the
  sample demo circuit starts without errors.
- The `src/js/main.wasm` file is generated by `make`; avoid committing changes to it.
- UI code resides under `src/go/internal/ui`. The test suite can run either
  against a stubbed Ebiten (`go.test.mod`) or the real library.
  - For native builds and browser tests, run `sudo make dependencies` once to execute
    `scripts/setup-env.sh` which installs all required system packages and Node
    dependencies.
- Building with the real Ebiten module requires network access on the first run
  so Go can download dependencies. If networking is disabled, use the stubbed
  modules or ensure all packages are vendored.

### Git sync
After cloning the repository, make sure your local branch tracks the latest
remote branch used for development:

```sh
git remote add origin https://github.com/ingyamilmolinar/tunkul.git  # if not set
git fetch origin
git pull --no-rebase origin <development-branch>
```
Resolve any merge conflicts before proceeding.

### Headless X11
Install `xvfb` and run the game via `xvfb-run` on systems without a display:

```sh
sudo apt-get install -y xvfb
xvfb-run go run ./cmd/tunkul.go
```
The virtual framebuffer lets Ebiten create a window while logs are printed to the console.

## Project Overview
Tunkul is a grid-based beat sequencer written in Go with Ebiten. The program
renders a node graph where each node represents a drum hit. A bottom drum-machine
panel shows the active steps. The scheduler in `core/beat` triggers beats at a
configurable BPM using the pure data structures from `core/model`. The UI layer
translates mouse and keyboard input into model operations and draws the results
with Ebiten.

Key technologies:
- Go 1.23
- Ebiten for cross-platform rendering (stubbed for headless tests)
- WASM build via `make wasm`

### Git hooks
Run the following command once after cloning to ensure tests and the wasm build
run before every commit:

```sh
git config core.hooksPath .githooks
```

The provided pre-commit hook formats code, runs `go test -tags test -modfile=go.test.mod -timeout 1s ./...`,
and runs `make wasm`.

Code structure:
- `core/model` – pure graph and drum row logic (unit tested)
- `core/beat` – beat scheduler (integration tested)
- `internal/ui` – controller and renderer using Ebiten. Input helpers can be
  swapped during tests with `SetInputForTest` so UI logic can run headlessly.
  UI functional tests live in this package and verify button behaviour and
  layout sizing.

## Learnings from Bug Fixing
*   **UI Debugging with Logs:** For UI-related bugs, extensive logging of UI and logic states is crucial. `log.Printf` statements at key points (e.g., `Update` loops, state changes, event handlers) provide invaluable insight into runtime behavior that unit tests alone cannot capture.
*   **Functional Testing for UI:** Unit tests are good for isolated logic, but functional tests that simulate user interactions (like button clicks) and assert on visual outcomes (e.g., pulse animation, drum row content) are essential for UI correctness.
*   **Clear Separation of Concerns:** Ensuring a clear separation between the model (pure data and logic), the scheduler (beat timing), and the UI (rendering and input) simplifies debugging and testing. Changes in one layer should propagate predictably to others.
*   **Graph Traversal for Derived Data:** When UI elements (like the drum beat row) are derived from a complex data structure (like a node graph), implement explicit traversal logic (e.g., BFS/DFS) to generate the derived data. Avoid direct manipulation of derived data in multiple places.
*   **Test Setup and Teardown:** Pay close attention to test setup (`New()`, `Layout()`, `StartNodeID` initialization) and teardown (`defer restore()`) to ensure tests are isolated and repeatable.
*   **Iterative Refinement:** Debugging complex interactions often requires an iterative approach: add logs, observe, refine code, re-test. Don't afraid to revert changes if they lead to more issues.

## Learnings from Signal Propagation Bug
This debugging session highlighted several critical points:

*   **Precise `replace` command usage:** The `replace` tool requires an *exact* match for `old_string`, including all whitespace and newlines. Even a single character mismatch will result in failure. When encountering "0 occurrences found," it's crucial to re-read the target file to get the exact content.
*   **Avoiding infinite loops:** When a fix involves multiple interdependent changes (code and tests), it's easy to get into a loop where fixing one part breaks another, or the changes aren't applied correctly. A systematic approach is vital:
    1.  **Isolate the problem:** Use logging and targeted tests to narrow down the root cause.
    2.  **Plan changes comprehensively:** Before making any changes, outline all necessary modifications to code and tests.
    3.  **Apply changes incrementally:** Make small, verifiable changes and run tests after each step.
    4.  **Prioritize core logic:** Ensure the fundamental behavior is correct before addressing secondary issues.
    5.  **Re-evaluate assumptions:** If a fix isn't working, question underlying assumptions about the code's behavior.
*   **Clear Separation of Concerns (Revisited):** The initial bug stemmed from the scheduler having too much knowledge about the graph structure. By simplifying the scheduler to only provide a basic `OnTick` event and moving the graph traversal and pulse propagation logic to the UI layer (`game.go`), the system became much more modular and easier to debug. This reinforces the principle that each component should have a single, well-defined responsibility.
*   **Event-driven architecture:** Implementing pulse propagation as an event-driven system (where a pulse completing its animation triggers the next node) is more robust and intuitive than a centralized scheduler trying to manage all node activations. This allows for more complex and dynamic signal flows.
*   **Test synchronization:** When refactoring core logic, tests need to be updated to reflect the new behavior. It's important to understand *why* a test is failing (e.g., due to a bug or an outdated expectation) and adjust it accordingly. Adding logging to tests can help verify that the test setup and execution are behaving as expected.
*   **Directed Graph Edge Consistency:** When working with directed graphs, ensure that edge creation consistently reflects the intended direction. Incorrectly swapping 'from' and 'to' nodes during intermediate node generation can lead to subtle bugs in graph traversal and cycle detection, as the underlying graph structure might not match the logical flow. Always verify that the graph's internal representation of edges aligns with the conceptual direction of connections. This was the root cause of the `IsLoop` function failing to detect cycles in `TestDrumViewLooping`.

## Lessons from Highlight Rendering Refactor
*   **Injectable rendering helpers:** Defining drawing primitives as variables allows tests to capture render calls without relying on pixel buffers, closing the gap between logic state and visual output.
*   **Centralized highlight bookkeeping:** Small helper methods to add and expire beat highlights make the pulse traversal logic easier to reason about and avoid dangling highlights.
*   **Conditional beat-row recomputation:** Rebuilding drum rows only when their length changes keeps the UI in sync with the graph while avoiding unnecessary work each frame.

## Lessons from Invisible Node Handling
*   **Upgrade placeholders on demand:** When a user tries to place a node where an invisible placeholder exists, automatically promote it to a regular node so intersections always accept new placements.

## Lessons from Audio Integration
*   **Procedural sound plugins:** Generate percussion without binary assets by exposing a `register/play` API in JS and invoking it via a `playSound` function variable in Go so tests can intercept calls.
*   **Uncapped TPS for smoother timing:** Running Ebiten with `SetMaxTPS(0)` removes the default tick limit, keeping visual pulses and audio in sync with the scheduler's BPM.
*   **Resume Web Audio contexts:** Browsers start `AudioContext` in a suspended state; calling `resume()` on first playback ensures sounds are heard after a user gesture. Native builds use Oto to synthesize a noise-based snare.
*   **Load audio modules before WASM:** Import ES modules like `audio.js` inside a module script that also boots the WASM game so the JS bridge functions (e.g., `play`) are defined before Go tries to call them.

## Lessons from Audio Loop Consistency
*   **Highlight-driven sound:** Invoke audio playback from the beat-highlighting routine so signal traversal, drum view highlighting, and audible cues remain in lockstep—even through graph loops.
*   **Dynamic drum length:** Size the drum view based on the number of traversed nodes so long circuits with many invisible intersections play and render correctly without truncation.

## Lessons from Drum View Dragging
*   **Independent drum view input:** Handling drum-view dragging separately from the grid prevents camera panning and scrolls the beat window via an offset, letting users follow highlights that move beyond the initial view.

## Lessons from Tempo Changes
*   **Rescale in-flight pulses on tempo changes:** When BPM updates, scale the active pulse's progress and recompute audio scheduling so the signal keeps moving forward without jumping or reversing.

## Miniaudio Integration Notes

* Miniaudio is compiled to WebAssembly via `emcc` during `make wasm`, producing `drums.js` at build time.
* JavaScript wrapper `audio.js` exposes `window.playSound(id)` used by the Go runtime on WASM builds.
* Current integration triggers snare and kick playback but does not yet support precise scheduling or mixing with Go's audio engine.

## DrumView multi-row

* Drum view UI now supports adding and deleting rows with `+` and per-row delete buttons.
* Instruments are tracked per row and can be cycled for the selected row.
* Each drum row tracks a distinct origin node. After adding a row, the next grid click assigns its origin, and deleting a row removes the associated node from the graph.
* Row additions are now reported via `ConsumeAddedRows`, and each row stores a pointer to its origin UI node so `Game` no longer keeps a separate `startNodes` slice.
* Beat paths are computed per drum row via `beatInfosByRow`, with the first row auto-syncing its origin to the game start node.
* The global instrument selector next to the upload button has been removed. Upload is now the only top-level control, and instrument changes occur via per-row labels.
* `Game` creates a centered origin node for row 0 by default; tests can disable this via `SetDefaultStartForTest(false)`.
* Signals now propagate concurrently from each row's origin and trigger per-row instrument playback.
* Drum view now highlights beats for every row based on encoded row/index keys.
* Beat highlight keys are stored with absolute beat indices so the drum view markers remain in sync with the timeline cursor.
* The drum view reserves an extra row for a trailing "+" button so existing grids remain intact; adding a row no longer clears the grid and awaits the user's next grid click for origin placement.
* Row labels are clickable to cycle instruments, and a fixed 24px row height with internal padding keeps per-row buttons aligned without overlapping the transport panel.
* Control panel uses a grid-based component system (`uigrid.go`) with declarative buttons and centered text to prevent overlapping layouts.
* Each drum row exposes a volume slider with percentage readout; `Game` passes the row’s volume to audio playback.
* Editing a row name shows a blinking cursor immediately and hides the underlying label to avoid visual artifacts.
* The last remaining drum row cannot be deleted; its delete button is disabled.
* Volume sliders now capture mouse drags, so releasing over other controls no longer triggers unintended actions; regression tests cover this.
* Fixed loop traversal so pulses transition from the last node back to the loop start without jumping to the origin.
* Nodes and drum cells are color-coded per instrument; origin nodes use a brighter shade.
* Each row has a "set origin" button that lets the next grid click reassign its start node.
* Pulse advancement now panics if a signal revisits its origin out of sequence, helping catch loop-order bugs in tests.
* Deleting a drum row now purges its active pulses and shifts remaining rows so orphaned signals can't panic.
* Reset origin-sequence bookkeeping on seek or playback restarts to avoid false "pulse jumped to origin" panics; regression tests cover this.
* Row labels now include a small edit button to rename instruments; the rename dialog uses a blinking block cursor and key-repeat timing consistent with button holds.

## Grid resolution refactor (WIP)

* Introduced a `Grid` struct with configurable step size to replace the fixed `GridStep` constant.
* Game logic and tests now obtain spacing through this struct, easing future support for higher beat subdivisions.
* Added subdivision definitions with per-level styles and zoom thresholds, and render them in `drawGridPane`.
* Sorted subdivision levels and removed overlapping lines so beat-level markers remain distinct.
* Grid clicks now snap to the finest subdivision, allowing node placement at 32nd-note intersections.
* Node and signal sizes now scale with zoom so 32nd-note nodes never overlap.
* Sub-beat nodes now populate drum-row steps, enabling sequencing at 32nd-note resolution.
* Pulse speed scales with grid distance so signals traverse one beat per main intersection; tests cover 32nd-note traversal.
* Grid line generation now pads the visible area by one beat so panning reveals a seamless infinite lattice.
* Camera offsets now snap to integer pixels and clamp to a safe range so panning across vast distances stays performant and lines remain crisp.
* Mouse wheel zoom now scales smoothly around the cursor so the pointed world position stays fixed while zooming.
* Grid lines keep a consistent thin width at all zoom levels; color contrast differentiates beat subdivisions.
* Connection arrows shrink to 32nd‑note units, inherit node colors, and use a constant 1px thickness so links stay unobtrusive.
* Cursor shows a live (beat:sub-beat) coordinate label, and the default start node sits at (0:0) with the camera centered.
* Next steps: profile grid rendering at extreme pan/zoom combinations for further optimizations.
